#include <stdio.h>
#include "MainFrame.h"
#include "StartFrame.h"
#include "TCanvas.h"
#include <string>
#include <unistd.h>
#include <sys/stat.h>
#include <iostream>
#include "TMath.h"

const char* MainFrame::filetypes[] = { "config files",   "*.cfg",
                                        "All files",     "*.*",
				       0,               0 };

typedef std::pair<std::string,void*> NamedPt;

ClassImp(MainFrame)


MainFrame::MainFrame(const TGWindow *p, int argc, char **argv,UInt_t w, UInt_t h)
    : TObject(), fArgc(argc), fArgv(argv), fCurHisto(0), fCurPlane(0), fCurGroup(0) {
  fMain   = new TGMainFrame(p, w, h);
  fMain->Connect("CloseWindow()", "MainFrame", this, "CloseWindow()");
#if ROOT_VERSION_CODE >= ROOT_VERSION(4,4,2)
  fMain->SetIconPixmap("compass_xpm");
#else
  #if AFS_ACCESS == 1
    fMain->SetIconPixmap("/afs/cern.ch/compass/detector/monitor/compass.xpm");
  #endif
#endif

  fMonitor=new Monitor();
  fVariousSettings = new VariousSettings(fMonitor);  
  fVariousSettings->ReadPersoParam();

  try {
    fStartFrame = new StartFrame(gClient->GetRoot(),this,200,400);
  }
  catch( ... ) {
    throw;
  }
}


void MainFrame::CloseWindow()
{
   // Got close message for this MainFrame. Calls parent CloseWindow()
   // (which destroys the window) and terminate the application.
   // The close message is generated by the window manager when its close
   // window menu item is selected.

  fTimer->TurnOff();
  fMonitor->SetClosingWindow(true);
  fMonitor->ThreadStopRequest();
  gSystem->Sleep(1000);
  for (register int ii=0; ii<50; ii++) {  // we don't wait indefinitly...
    if (fMonitor->GetThreadFinished()) break;
    gSystem->Sleep(4000);
  }
  fVariousSettings->WritePersoParam();
  delete fVariousSettings;
  delete fMonitor;
  gApplication->Terminate(0);
  // exit(0);
}


void MainFrame::HandleButtons(int id) {

  if (id == -1) {
    TGButton *btn = (TGButton *) gTQSender;
    id = btn->WidgetId();
  }

  switch(id) {
  case M_BUTTON_RESET:
    fMonitor->ResetTree();
    break;

  case M_BUTTON_SAVE:
    std::cout<<"save tree not yet implemented"<<std::endl;
    break;
  case M_BUTTON_PRINT:
    {
      std::cerr<<"Not yet implemented"<<std::endl;
      break;
    }
  case M_BUTTON_PANEL:
    fMonitor->ControlPanel(gClient->GetRoot(),fMain);
    break;
  case M_BUTTON_CLEAR:
    {
      gPad->Clear();
      gPad->Modified();
      gPad->Update();

      //              register TObject* cvo;
      //              register TSeqCollection *allCanvas;
      //              register TIter* nextcv;
      //              allCanvas = gROOT->GetListOfCanvases();
      //              nextcv = new TIter(allCanvas);
      //              while ((cvo = (TObject*) (*nextcv)())) {
      //                register TCanvas* cv;
      //                if ((cv = (TCanvas*)(cvo))) {
      //                  cv->Clear();
      //                  cv->Modified();
      //                  cv->Update();
      //                }
      //              }
      break;
    }

  case M_BUTTON_STOP :
    fMonitor->ThreadStopRequest();
    break;

  case M_BUTTON_RESETHISTS:
    { fMonitor->ResetHistos(); break; }

  case M_BUTTON_NEWCANVAS:
      if (thr_flag) TThread::Lock();
      if (fCurHisto)
        {
	  register TCanvas* canvas;
	  register const char* name;
	  register std::string* stname;
	  name = fCurHisto->GetName();
	  stname = new std::string(name);
          *stname = std::string("Canvas_") + *stname;
	  canvas = new TCanvas(stname->c_str(), stname->c_str(), 600, 350);
	  fCanvasMap[*stname] = canvas;
	  canvas->cd();
	  fCurHisto->Draw();
	  gPad->Modified();
	  gPad->Update();
        }
      if (thr_flag) TThread::UnLock();
      break;

    case M_BUTTON_PUTSELECTED:
      if (thr_flag) TThread::Lock();
      if (fCurHisto && gPad)
        {
	  fCurHisto->Draw();
	  gPad->Modified();
	  gPad->Update();
        }
      if (thr_flag) TThread::UnLock();
      break;

    case M_BUTTON_PUTINCANVAS:
      if (thr_flag) TThread::Lock();
      if (fCurHisto)
        {
	  register int nbh = 0;
	  std::vector<TH1*> leshistos;
	  register TCanvas* cv = gPad->GetCanvas();
	  TIter next(cv->GetListOfPrimitives());
	  register TObject* p;
	  while ((p = (TObject*)next())) { // loop on all the canvas members
	    //		  cout << nbh << " " << p->IsA()->GetName() << std::endl;
	    if (p->IsA()->InheritsFrom("TH1")) {  // it is an histos
	        register RefHist *leref=dynamic_cast<RefHist*>(p);
                if (!leref) {  // ref histos not taken in account
		  leshistos.push_back(dynamic_cast<TH1*>(p));  // store it
		  nbh++;
                }
	      } else if (p->IsA()->InheritsFrom("TPad")) {
	      // it is a pad -> loop on all its members
	      TIter nextpd(dynamic_cast<TPad*>(p)->GetListOfPrimitives());
	      register TObject* q;
	      while ((q = (TObject*) nextpd())) {
	        //	 cout << "pd " << nbh << " " << q->IsA()->GetName() << std::endl;
	        if (q->IsA()->InheritsFrom("TH1")) {  // it is an histo
	          register RefHist *leref=dynamic_cast<RefHist*>(q);
                  if (!leref) {  // ref histos not taken in account
                    leshistos.push_back(dynamic_cast<TH1*>(q));
		    nbh++;
		  }
	        }     // NB: we don't loop recursively on subsubpads (may be later...)
	      }
	    }
	  }
	  leshistos.push_back(fCurHisto); nbh++; // we add the new histo
	  register int nbhsqrt = (int) sqrt(nbh), jj;
	  for (jj = nbhsqrt; nbhsqrt*jj < nbh; jj++);  // pad geometry computation
	  cv->Clear();	// we remove all the old pads
	  if( cv->GetWindowWidth() > cv->GetWindowHeight() ) cv->Divide(jj, nbhsqrt);
	  else cv->Divide(nbhsqrt, jj);
	  for (jj = 0; jj < nbh; jj++) {  // fill up of the pads
	    cv->cd(jj+1);
	    leshistos[jj]->Draw();
	  }
          cv->Modified();
          cv->Update();
        }
      if (thr_flag) TThread::UnLock();
      break;

    case M_BUTTON_PROPERTIES:
      if(fCurPlane) {
        fCurPlane->ControlPanel(gClient->GetRoot(),fMain);
      } else if (fCurGroup) {
	fCurGroup->ControlPanel(gClient->GetRoot(),fMain);
      }
      break;

    case M_CHECKBUTTON_RUNCLEAR:
      if (fRunClearButton->GetState() == kButtonDown) {
        fMonitor->SetRunClear(true); std::cerr<<"clear at each BOR\n";
      } else {
        fMonitor->SetRunClear(false); std::cerr<<"no clear at each BOR\n";
      }
      break;

    case M_CHECKBUTTON_STOPGO:
      if (fStopGoButton->GetState() == kButtonDown) {
        fMonitor->SetStopGo(true); std::cerr<<"Suspend events reading\n";
      } else {
        fMonitor->SetStopGo(false); std::cerr<<"Restart events reading\n";
      }
      break;

    default:
      break;
  }
}


void MainFrame::SelectedGroup(int id) {

  fHistListBox->AddEntry("",fCurHists.size()+1);
  fHistListBox->Select(fCurHists.size()+1);
  fHistListBox->MapSubwindows();
  fHistListBox->Layout();
  fHistListBox->RemoveEntries(0,fCurHists.size()+1);
  Group* grp=fMonitor->GetGroup(fGroupListVec[id]);
  fCurHists=grp->GetHistoList();
  for (register unsigned int i=0;i<fCurHists.size();i++) {
    fHistListBox->AddEntry(fCurHists[i]->GetName(),i);
  } 	
  fHistListBox->MapSubwindows();
  fHistListBox->Layout();
}


void MainFrame::ClickedGroup(TGListTreeItem* item, int btn) {
  register NamedPt *npt;

  if (btn != 1) return;

  npt = (NamedPt*) item->GetUserData();
  if (npt->first == "Group") {
    fCurPlane = 0;
    fCurGroup = (Group*) npt->second;

    fHistListBox->AddEntry("",fCurHists.size()+1);
    fHistListBox->Select(fCurHists.size()+1);
    fHistListBox->MapSubwindows();
    fHistListBox->Layout();
    fHistListBox->RemoveEntries(0,fCurHists.size()+1);
    fCurHists=fCurGroup->GetHistoList();
    for (register unsigned int i=0;i<fCurHists.size();i++) {
      fHistListBox->AddEntry(fCurHists[i]->GetName(),i);
    } 	
    fHistListBox->MapSubwindows();
    fHistListBox->Layout();
  }
  else if (npt->first == "Plane") {

    fCurGroup=0;
    fCurPlane = (Plane*) npt->second;

    fHistListBox->AddEntry("",fCurHists.size()+1);
    fHistListBox->Select(fCurHists.size()+1);
    fHistListBox->MapSubwindows();
    fHistListBox->Layout();
    fHistListBox->RemoveEntries(0,fCurHists.size()+1);
    fCurHists = fCurPlane->GetHistoList();
    for (register unsigned int i=0;i<fCurHists.size();i++) {
      fHistListBox->AddEntry(fCurHists[i]->GetName(),i);
    } 	
    fHistListBox->MapSubwindows();
    fHistListBox->Layout();
  }
}


void MainFrame::DoubleClickedGroup(TGListTreeItem* item, int btn) {
  register NamedPt *npt;

  if (btn != 1) return;

  npt = (NamedPt*) item->GetUserData();
  if (npt->first != "Group" && npt->first != "Folder") return;  
  // only groups and Folders can be opened 
  
  if (!item->IsOpen()) { fGroupListTree->CloseItem(item); }  // IsOpen says if it is closed !!
  else { fGroupListTree->OpenItem(item); }
  fGroupListTree->UnmapWindow();
  fGroupLTCanvas->MapSubwindows();
  fGroupLTCanvas->Layout();
  return;
}


void MainFrame::SelectedHist(int id) {

  register TPad *oldpad, *padcanvas;
  register TCanvas* cv;
  if (thr_flag) TThread::Lock();
  oldpad = dynamic_cast<TPad*>(gPad);
  fCurHisto=fCurHists[id];
  cv = fCanvasWindow->GetCanvas();
  padcanvas = (TPad*) cv->GetSelectedPad(); // last pad selected in this Canvas (does it work ??? )
  if (! padcanvas) {  // no selected pad
    TIter nextcv(cv->GetListOfPrimitives());
    register TObject *p;
    while ((p = (TObject*)nextcv())) { // loop on all the canvas members to find the last Pad
      if (p->IsA()->InheritsFrom("TPad")) padcanvas = (TPad*) p;
    }
  }
  if (padcanvas) { padcanvas->cd(); }
  else { cv->Clear(); cv->cd(); } // if still no pad found, put histo on canvas
  fCurHisto->Draw();
  gPad->Modified();
  gPad->Update();
  oldpad->cd();
  if (thr_flag) TThread::UnLock();
}


void MainFrame::HandleMenu(int id) {
  TGFileInfo fi;

  switch (id) {
	
    case M_FILE_OPEN:
      {
        fi.fFileTypes = CHAR_TGFILEINFO(filetypes) ;
        new TGFileDialog(gClient->GetRoot(), fMain, kFDOpen,&fi);
        if (fi.fFilename) {
	  if (fVariousSettings->LoadConfigSettings(fi.fFilename)) {
//       map<std::string,Plane*>& planes=fMonitor->GetDetMap();
//       typedef map<std::string,Plane*>::iterator PI;
//       for(PI ip=planes.begin(); ip!=planes.end(); ip++)
// 	(*ip).second->ResetHistograms();

//       map<std::string,Group*>& groups=fMonitor->GetGroupMap();
//       typedef map<std::string,Group*>::iterator GI;
//       for(GI ig=groups.begin(); ig!=groups.end(); ig++)
// 	(*ig).second->ResetHistograms();
	    std::cerr << "File " << fVariousSettings->GetConfigFileName() << " loaded\n";
            FillPreviousMenu();
            break;
	  }
	  // delete fi.fFilename;  // done by the TGFileInfo destructor
        } else {
	  std::cerr << "Open config canceled\n";
        }
      }
      break;

    case M_FILE_SAVE:
      if (fVariousSettings->HasConfigFileName()) {
        fVariousSettings->SaveConfigSettings();
        std::cerr << "File " << fVariousSettings->GetConfigFileName() << " saved with all config infos\n";
        FillPreviousMenu();
        break;
      }
      // NO BREAK: go from save to save_as step when no default file name
    case M_FILE_SAVEAS:
      {
        fi.fFileTypes = CHAR_TGFILEINFO(filetypes);
        new TGFileDialog(gClient->GetRoot(), fMain, kFDSave,&fi);
        if (fi.fFilename) {
	  fVariousSettings->SaveConfigSettings(fi.fFilename);
	  std::cerr << "File " << fi.fFilename << " saved with all config infos\n";
          FillPreviousMenu();
	  // delete fi.fFilename;  // done by the TGFileInfo destructor
        } else {
	  std::cerr << "Save all config canceled\n";
        }
      }
      break;	

    case M_GUIFILE_SAVEAS:
      {
        fi.fFileTypes = CHAR_TGFILEINFO(filetypes) ;
        new TGFileDialog(gClient->GetRoot(), fMain, kFDSave,&fi);
        if (fi.fFilename) {
	  fVariousSettings->SaveConfigSettings(fi.fFilename, 1);
	  std::cerr << "File " << fi.fFilename << " saved with gui config infos\n";
          FillPreviousMenu();
	  // delete fi.fFilename;  // done by the TGFileInfo destructor
        } else {
	  std::cerr << "Save gui config canceled\n";
        }
      }
      break;	

    case M_PLANEFILE_SAVEAS:
      {
        fi.fFileTypes = CHAR_TGFILEINFO(filetypes);
        new TGFileDialog(gClient->GetRoot(), fMain, kFDSave,&fi);
        if (fi.fFilename) {
	  fVariousSettings->SaveConfigSettings(fi.fFilename, 2);
	  std::cerr << "File " << fi.fFilename << " saved with planes and groups config infos\n";
          FillPreviousMenu();
	  // delete fi.fFilename;  // done by the TGFileInfo destructor
        } else {
	  std::cerr << "Save planes and groups config canceled\n";
        }
      }
      break;

    case M_GUIFILE_CREATEPS:
      {
        fi.fFileTypes = CHAR_TGFILEINFO(filetypes);
        new TGFileDialog(gClient->GetRoot(), fMain, kFDOpen,&fi);
        if (fi.fFilename) {
	  if (fVariousSettings->GuiSettingsCreatePS(fi.fFilename)) {
	    std::cerr << "PS file created from file " << fi.fFilename << "\n";
	  }
	  // delete fi.fFilename;  // done by the TGFileInfo destructor
        } else if (fi.fFileNamesList) {
 	  if (fVariousSettings->GuiSettingsCreatePS("", fi.fFileNamesList)) {
	    std::cerr << "PS file created from file list\n";
	  }
       } else {
	  std::cerr << "PS file creation canceled\n";
        }
      }
      break;

    case M_ORDERLY_SHIFT_PLOTS:
      fVariousSettings->GuiSettingsCreateOrderlyShiftPlots();
      break;

    case M_FILE_EXIT:
      CloseWindow();   // this also terminates theApp
      break;

    default:
      break;
  }
}


void MainFrame::HandlePreviousMenu(int id) {
  const std::vector<std::string>& filenamelist = fVariousSettings->GetConfigFileNameList();
  if ((id >= 0) && (id < (int) filenamelist.size())) {
    if (!fVariousSettings->LoadConfigSettings(filenamelist[id])) {
      std::cerr << "Can't open file " << filenamelist[id] <<std::endl;
    } else {
      FillPreviousMenu();
      std::cerr << "File " << fVariousSettings->GetConfigFileName() << " loaded\n";
    }
  } else {
    std::cerr << "MainFrame::HandlePreviousMenu: bug, 'previous' menu item " << id << " does not exist\n";
  }
}


void MainFrame::HandlePrtPreviousMenu(int id) {
  const std::vector<std::string>& filenamelist = fVariousSettings->GetConfigFileNameList();
  if ((id >= 0) && (id < (int) filenamelist.size())) {
    if (!fVariousSettings->GuiSettingsCreatePS(filenamelist[id])) {
      std::cerr << "Can't open file " << filenamelist[id] <<std::endl;
    } else {
      FillPreviousMenu();
      std::cerr << "PS file created from file " << filenamelist[id] << "\n";
    }
  } else {
    std::cerr << "MainFrame::HandlePrtPreviousMenu: bug, 'previous' menu item " << id << " does not exist\n";
  }
}


void MainFrame::Init() {
  // Connected to fStartFrame Start button

  fStartFrame->Hide();

  std::string forcedref = fStartFrame->GetRefEntry();
  if (forcedref != "") {
    int runnb;
    std::string refname = "";
    if (sscanf(forcedref.c_str(), "%d", &runnb)) {
      // it's a run number, let see if root file in References dir
      char strrun[100];
      sprintf(strrun, "%d", runnb);
      refname = "/afs/cern.ch/compass/detector/monitor/References/coool_";
      refname += strrun;
      refname += ".root";
      struct stat statbuf;
      if ( stat(refname.c_str(), &statbuf) || (!S_ISREG(statbuf.st_mode))) {
        // does not exists or not a good file, using web file
//         refname = "http://pccoeb03.cern.ch/rootfile.php/runnb=";
        refname = "http://wwwcompass.cern.ch/rootfile.php/runnb=";
        refname += strrun;
      }
    } else {
      // it's a file name in References dir
      refname = "/afs/cern.ch/compass/detector/monitor/References/";
      refname += forcedref;
    }
    Plane::ForceRefFileName(refname.c_str());
    Group::ForceRefFileName(refname.c_str());
  }

  fMonitor->Init(fStartFrame->GetMapFile(),
		 fStartFrame->GetRootFile(),
		 fStartFrame->GetDataFile(),
		 fStartFrame->GetGroupFile(),
		 fStartFrame->GetGeomFile());
  fMonitor->SetEventNumber(fStartFrame->GetNEvent());
  fMonitor->SetEventSpacing(fStartFrame->GetMinEventSpacing());

  // load defaults histo settings
  if (fStartFrame->GetParamFile() != "") fVariousSettings->LoadDefaultSettings(fStartFrame->GetParamFile());

  // file menu
  fMenuFile = new TGPopupMenu(gClient->GetRoot());
  fMenuFile->AddEntry("&Open any config...", M_FILE_OPEN);
//   fMenuFile->AddEntry("&Save all config", M_FILE_SAVE); // removed to disciplinate people
//   fMenuFile->AddEntry("S&ave all config as...", M_FILE_SAVEAS);
  fMenuFile->AddEntry("Save &gui config as...", M_GUIFILE_SAVEAS);
  fMenuFile->AddEntry("Save &planes&groups config as...", M_PLANEFILE_SAVEAS);
  fMenuFile->AddSeparator();
// printing not yet ready....
  fMenuFile->AddEntry("&Create PS file from config...", M_GUIFILE_CREATEPS);
  fMenuFile->AddEntry("Create Orderly S&hift Plots...", M_ORDERLY_SHIFT_PLOTS);
  fMenuFile->AddSeparator();
  fMenuFile->AddEntry("E&xit", M_FILE_EXIT);
  fMenuFile->Connect("Activated(int)", "MainFrame", this,
		     "HandleMenu(int)");

  // previous open files menu and print previous open files menu
  fMenuPrevious = new TGImprovedPopupMenu(gClient->GetRoot());
  fMenuPrtPrevious = new TGImprovedPopupMenu(gClient->GetRoot());
  FillPreviousMenu();
  fMenuPrevious->Connect("Activated(int)", "MainFrame", this,
		         "HandlePreviousMenu(int)");
  fMenuPrtPrevious->Connect("Activated(int)", "MainFrame", this,
		            "HandlePrtPreviousMenu(int)");

  //menu bar
  fMenuBarLayout = new TGLayoutHints(kLHintsTop | kLHintsLeft
				     | kLHintsExpandX,0, 0, 1, 1);
  fMenuBarItemLayout = new TGLayoutHints(kLHintsTop | kLHintsLeft,
					 0, 4, 0, 0);
  fMenuBar = new TGMenuBar(fMain, 1, 1, kHorizontalFrame);
  fMenuBar->AddPopup("&File", fMenuFile, fMenuBarItemLayout);
  fMenuBar->AddPopup("Open &previous cfg file", fMenuPrevious, fMenuBarItemLayout);
  fMenuBar->AddPopup("&Create PS from prev. cfg file", fMenuPrtPrevious, fMenuBarItemLayout);


  //center frame
  fCenterFrame = new TGCompositeFrame(fMain,60,60, kHorizontalFrame);

  //left group frame
  fLeftFrame = new TGCompositeFrame(fCenterFrame,60,60, kVerticalFrame);

  // Group group frame (huhu !)
  fGroupFrame = new TGGroupFrame(fLeftFrame,"Groups", kVerticalFrame);

  //Group list
  fGroupLTCanvas = new TGCanvas(fGroupFrame, 10, 10, kSunkenFrame | kDoubleBorder);
  fGroupListTree=new TGListTree(fGroupLTCanvas->GetViewPort(), 30, 30, kHorizontalFrame);
  fGroupLTCanvas->SetContainer(fGroupListTree);
  fGroupListTree->SetCanvas(fGroupLTCanvas);
#if ROOT_VERSION_CODE >= ROOT_VERSION(5,16,0)
  fGroupLTCanvas->GetVScrollbar()->SetAccelerated(kTRUE);
#endif
#if ROOT_VERSION_CODE == ROOT_VERSION(5,14,0)
  fGroupLTCanvas->GetVScrollbar()->SetSmallIncrement(12);
#endif

  std::map<std::string,Group*>& groupmap=fMonitor->GetGroupMap();
  typedef std::map<std::string,Group*>::iterator GI;
  typedef std::vector<const Plane*>::iterator PLI;
  TGListTreeItem *allplanes = NULL;
  for(GI gi=groupmap.begin();gi!=groupmap.end();gi++) {
    register Group* grp;
    register TGListTreeItem* item;
    grp = gi->second;
    char stbuf[200];
    
    std::string pathname("/"); pathname += grp->GetType();
    TGListTreeItem *path = fGroupListTree->FindItemByPathname(pathname.c_str());
    if(!strcmp(grp->GetName(),"All Planes"))
      allplanes = item = fGroupListTree->AddItem(0, (gi->first).c_str(),
						 (void*) new NamedPt("Group", (void*) grp));
    else { 
      if(!path)
	path = fGroupListTree->AddItem(0, grp->GetType(),
				       (void*) new NamedPt("Folder", 0));      
      item = fGroupListTree->AddItem(path, (gi->first).c_str(),
				     (void*) new NamedPt("Group", (void*) grp));
    }


    std::vector<const Plane*>& planesofgroup = grp->GetPlane();
    fGroupListVec.push_back((gi->first).c_str());

    sprintf(stbuf, "Group of type %s", grp->IsA()->GetName());
    fGroupListTree->SetToolTipItem(item, stbuf);
    for (PLI pli = planesofgroup.begin(); pli != planesofgroup.end(); pli++) {
      register TGListTreeItem* item2;
      item2 = fGroupListTree->AddItem(item, ((Plane*)*pli)->GetName(),
                            (void*) new NamedPt("Plane", (void*) *pli),
                            gClient->GetPicture("profile_t.xpm"),
                            gClient->GetPicture("profile_t.xpm"));
      sprintf(stbuf, "Plane of type %s", (*pli)->IsA()->GetName());
      fGroupListTree->SetToolTipItem(item2, stbuf);
    }
    fGroupListTree->SortChildren(item);
  }
  fGroupListTree->SortSiblings(allplanes);
  //  fGroupListBox->Connect("Selected(int)", "MainFrame", this, "SelectedGroup(int)");
  fGroupListTree->Connect("Clicked(TGListTreeItem*, int)", "MainFrame", this,
                          "ClickedGroup(TGListTreeItem*, int)");
  fGroupListTree->Connect("DoubleClicked(TGListTreeItem*, int)", "MainFrame", this,
                          "DoubleClickedGroup(TGListTreeItem*, int)");
  fGroupFrame->AddFrame(fGroupLTCanvas,new TGLayoutHints(kLHintsTop |
						      kLHintsExpandX |
						      kLHintsExpandY,
						      5, 5, 5, 5));
  fGroupLTCanvas->Resize(200,200);

  //properties button
  fProperties = new TGTextButton(fGroupFrame, "&Properties",
  					M_BUTTON_PROPERTIES);
  fProperties->SetToolTipText("Plane Properties");
  fProperties->Connect("Clicked()", "MainFrame", this, "HandleButtons()");
  fGroupFrame->AddFrame(fProperties, new TGLayoutHints(kLHintsTop |
							    kLHintsExpandX |
						            kLHintsLeft,
						            2, 2, 2, 2));


  // histogram group frame ------------------------------------------------

  fHistFrame = new TGGroupFrame(fCenterFrame,"Histograms", kVerticalFrame);

  //histogram list box
  fHistListBox =  new TGListBox(fHistFrame, M_LISTBOX_HISTO);
  fHistListBox->Connect("Selected(int)", "MainFrame", this,
			"SelectedHist(int)");

  fHistFrame->AddFrame(fHistListBox,new TGLayoutHints(kLHintsTop |
						      kLHintsLeft |
						      kLHintsExpandY,
						      5, 5, 5, 5));

  fLeftFrame->AddFrame(fGroupFrame,new TGLayoutHints(kLHintsTop |
						      kLHintsLeft |
						      kLHintsExpandY |
						      kLHintsExpandX,
						      0, 0, 0, 0));
  fCenterFrame->AddFrame(fLeftFrame,new TGLayoutHints(kLHintsTop |
						      kLHintsLeft |
						      kLHintsExpandY,
						      2, 2, 2, 2));
  fCenterFrame->AddFrame(fHistFrame,new TGLayoutHints(kLHintsTop |
						      kLHintsLeft |
						      kLHintsExpandY,
						      2, 2, 2, 2));

  // Canvas windows handling
  TGLabel* l_histo = new TGLabel(fHistFrame, "Put this histo...");
  fHistFrame->AddFrame(l_histo, new TGLayoutHints(kLHintsTop |
						   kLHintsExpandX |
						   kLHintsLeft,
						   2, 2, 2, 2));
  fNewCanvasButton = new TGTextButton(fHistFrame, "In new window",
  					M_BUTTON_NEWCANVAS);
  fNewCanvasButton->SetToolTipText("Put histo in a new window");
  fNewCanvasButton->Connect("Clicked()", "MainFrame", this, "HandleButtons()");

  fHistFrame->AddFrame(fNewCanvasButton, new TGLayoutHints(kLHintsTop |
							    kLHintsExpandX |
						            kLHintsLeft,
						            2, 2, 2, 2));
  fPutSelectedButton = new TGTextButton(fHistFrame, "To selected pad",
  					M_BUTTON_PUTSELECTED);
  fPutSelectedButton->SetToolTipText("Put histo in the selected pad, replacing the old one");
  fPutSelectedButton->Connect("Clicked()", "MainFrame", this, "HandleButtons()");
  fHistFrame->AddFrame(fPutSelectedButton, new TGLayoutHints(kLHintsTop |
							    kLHintsExpandX |
						            kLHintsLeft,
						            2, 2, 2, 2));
  fPutInCanvasButton = new TGTextButton(fHistFrame, "To selected window",
  					M_BUTTON_PUTINCANVAS);
  fPutInCanvasButton->SetToolTipText("Put histo in the window of the selected pad, by dividing it");
  fPutInCanvasButton->Connect("Clicked()", "MainFrame", this, "HandleButtons()");
  fHistFrame->AddFrame(fPutInCanvasButton, new TGLayoutHints(kLHintsTop |
							    kLHintsExpandX |
						            kLHintsLeft,
						            2, 2, 2, 2));

  // canvas ----------------------------------------------------------
  fCanvasWindow = new TRootEmbeddedCanvas("fCanvasWindow",fCenterFrame, 400, 400);
  fCenterFrame->AddFrame(fCanvasWindow,new TGLayoutHints(kLHintsTop |
						      kLHintsLeft |
						      kLHintsExpandX |
						      kLHintsExpandY,
						      2, 2, 2, 2));


  //execution control bar --------------------------------------------

  fControlFrame = new TGGroupFrame(fMain, "controls", kHorizontalFrame);

  fPanelButton  = new TGTextButton(fControlFrame, "&Panel", M_BUTTON_PANEL);
  fPanelButton->SetToolTipText("Open monitoring control panel");
  fPanelButton->Connect("Clicked()", "MainFrame", this, "HandleButtons()");
  fControlFrame->AddFrame(fPanelButton,new TGLayoutHints(kLHintsTop |
							   kLHintsLeft,
							   2, 2, 2, 2));

  fClearButton = new TGTextButton(fControlFrame, "&Clear Pad", M_BUTTON_CLEAR);
  fClearButton->SetToolTipText("Clear the selected Pad");
  fClearButton->Connect("Clicked()", "MainFrame", this, "HandleButtons()");
  fControlFrame->AddFrame(fClearButton, new TGLayoutHints(kLHintsTop |
							  kLHintsLeft,
							  2, 2, 2, 2));

  //decoding frame
  //fControlDecoding= new TGGroupFrame(fControlFrame,"Decoding",
  //				     kHorizontalFrame);

  //fStartButton = new TGTextButton(fControlDecoding, "&Start", M_BUTTON_START);
  //fStartButton->SetToolTipText("Start decoding");
  //fStartButton->Connect("Clicked()", "MainFrame", this, "HandleButtons()");
  fStopButton  = new TGTextButton(fControlFrame, "Close &data file", M_BUTTON_STOP);
  fStopButton->SetToolTipText("Stop reading events and close the data file");
  fStopButton->Connect("Clicked()", "MainFrame", this, "HandleButtons()");
  fControlFrame->AddFrame(fStopButton,new TGLayoutHints(kLHintsTop |
							   kLHintsLeft,
							   2, 2, 2, 2));

//  fPrintButton  = new TGTextButton(fControlFrame, "&Print...", M_BUTTON_PRINT);
//  fPrintButton->SetToolTipText("Print windows");
//  fPrintButton->Connect("Clicked()", "MainFrame", this, "HandleButtons()");
//  fControlFrame->AddFrame(fPrintButton,new TGLayoutHints(kLHintsTop |
//							   kLHintsLeft,
//							   2, 2, 2, 2));

  fStopGoButton = new TGCheckButton(fControlFrame, "Suspend/restart events reading", M_CHECKBUTTON_STOPGO);
  fStopGoButton->SetToolTipText("Events reading is suspended if checked");
  fStopGoButton->Connect("Clicked()", "MainFrame", this, "HandleButtons()");
  fControlFrame->AddFrame(fStopGoButton,new TGLayoutHints(kLHintsTop |
							   kLHintsLeft,
							   2, 2, 2, 2));

  fEvtCounter = new TGTextEntry(fControlFrame,new TGTextBuffer(10));
  fEvtCounter->SetState(kFALSE);

  //fControlDecoding->AddFrame(fStartButton,new TGLayoutHints(kLHintsTop |
  //						            kLHintsLeft,
  //					            2, 2, 2, 2));
  fControlFrame->AddFrame(fEvtCounter,new TGLayoutHints(kLHintsTop |
							   kLHintsRight,
							   2, 2, 2, 2));

//    fControlFrame->AddFrame(fControlDecoding,new TGLayoutHints(kLHintsTop |
//  							     kLHintsLeft |
//  							     kLHintsExpandX,
//  							     0, 0, 2, 2));

  fResetHistsButton = new TGTextButton(fControlFrame, "Clear all &histos", M_BUTTON_RESETHISTS);
  fResetHistsButton->SetToolTipText("Reset tree and all histograms");
  fResetHistsButton->Connect("Clicked()", "MainFrame", this, "HandleButtons()");
  fControlFrame->AddFrame(fResetHistsButton, new TGLayoutHints(kLHintsTop
							       |kLHintsRight,
							       2, 2, 2, 2));

  fRunClearButton = new TGCheckButton(fControlFrame, "Clear at new run", M_CHECKBUTTON_RUNCLEAR);
  fRunClearButton->SetToolTipText("Clear all the histos at new begin of run if checked");
  fRunClearButton->Connect("Clicked()", "MainFrame", this, "HandleButtons()");
  fRunClearButton->SetState(kButtonDown);
  fControlFrame->AddFrame(fRunClearButton,new TGLayoutHints(kLHintsTop |
							   kLHintsRight,
							   2, 2, 2, 2));

  fMain->AddFrame(fMenuBar, fMenuBarLayout);
  fMain->AddFrame(fCenterFrame, new TGLayoutHints(kLHintsExpandX
						   | kLHintsExpandY,
						   0, 0, 2, 2));
		

  fMain->AddFrame(fControlFrame, new TGLayoutHints(kLHintsBottom | kLHintsExpandX,
					   0, 0, 1, 0));


  fHistListBox->Resize(200,150);
  fEvtCounter->Resize(80,25);


  //put all together ---------------------------------------------------
  char runnum[10];
  sprintf(runnum,"%s%u","run ",fMonitor->GetRunNumber());
  std::string winname;
  winname="COMPASS monitoring  -  ";
  winname+=runnum;
  fMain->SetWindowName(winname.c_str());
  fMain->MapSubwindows();
  fMain->Resize(fMain->GetDefaultSize());
  fMain->MapWindow();

  fTimer = new TTimer(3000);
  fTimer->SetObject(this);
  fTimer->TurnOn();


  // load the user config file if it exists
  if (fStartFrame->GetConfigFile() != "") {
    fVariousSettings->LoadConfigSettings(fStartFrame->GetConfigFile());
  }

  thr_flag = true;
  fMonitor->ThreadStart();
}


Bool_t MainFrame::HandleTimer(TTimer *timer) {

  char evtnum[20];
  char runnum[20];
  sprintf(evtnum,"%d",fMonitor->GetEventNumber());
  sprintf(runnum,"%u",fMonitor->GetRunNumber());

  register TObject* cvo;
  if (thr_flag) TThread::Lock();
  TSeqCollection *allCanvas = gROOT->GetListOfCanvases();
  TIter nextcv(allCanvas);
  while ((cvo = (TObject*) nextcv())) {
    register TCanvas* cv;
    cv = dynamic_cast<TCanvas*>(cvo);
    if (cv) {
      register TObject* p;
      register TList *subpads=cv->GetListOfPrimitives();
      TIter next(subpads);
      while ((p=(TObject*)next())) {
	register TPad *pad=dynamic_cast<TPad*>(p);
	if(pad!=NULL) {
	  pad->Modified();
	}
      }
      cv->Modified();
      cv->Update();
    }
  }
  if (thr_flag) TThread::UnLock();

// std::cerr<<" evt counter: evtnum "<<evtnum<<" monitor evt number "<<fMonitor->GetEventNumber()<<std::endl;
  fEvtCounter->SetText(evtnum);
  fControlFrame->Layout();
  char strtmp[300];
  sprintf(strtmp, "COMPASS monitoring   -   run %s   event %s", runnum, evtnum);
  fMain->SetWindowName(strtmp);
  sprintf(strtmp, "mon %s", evtnum);
  fMain->SetIconName(strtmp);
//   fMain->MapWindow();
  if (fMonitor->GetThreadFinished()) fMonitor->ThreadStop();
  return true;
}


void MainFrame::FillPreviousMenu() {
  fMenuPrevious->DeleteAllEntries();
  fMenuPrtPrevious->DeleteAllEntries();
  const std::vector<std::string>& filenamelist = fVariousSettings->GetConfigFileNameList();
  for (register unsigned int i = 0; i < filenamelist.size(); i++) {
    fMenuPrevious->AddEntry(filenamelist[i].c_str(), i);
    fMenuPrtPrevious->AddEntry(filenamelist[i].c_str(), i);
  }
}



