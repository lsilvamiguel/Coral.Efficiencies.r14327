// $Id: DrawTracks3DFromCoral.cc,v 1.12 2006/06/16 15:21:47 conrad Exp $

/*!
   \file    DrawTracks3DFromCoral.cc
   \brief   The part of DrawTracks3D which is specific for loading tracks through alignment outputrunning together with coral
   \author  Hugo Pereira
   \version $Revision: 1.12 $
   \date    $Date: 2006/06/16 15:21:47 $
*/

#include "DaqDataDecoding/Exception.h"
#include "Coral.h"
#include "CsInit.h"
#include "CsRegistrySing.h"
#include "CsEvent.h"
#include "CsCluster.h"
#include "CsTrack.h"
#include "CsDetector.h"
#include "CsHelix.h"
#include "CsVertex.h"
#include "CsErrLog.h"

#include "DrawTracks3D.h"
#include "DetFileManager.h"
#include "DetectorInfo.h"
#include "Obj3D.h"
#include "Point.h"
#include <list>
#include <functional>

#include <TCanvas.h>
#include <TNode.h>
#include <TGTextEntry.h>

//! To sort helices according to their z position
//____________________________________________________________________
struct sortLx : public binary_function< CsHelix, CsHelix, bool > 
{ 
  bool operator() ( CsHelix lx0, CsHelix lx1 ) 
  { return ( lx0.getZ() < lx1.getZ() ); } 
};

//________________________________________
// do nothing - tracks are generated by coral
void  DrawTracks3D::LoadTracks( const char* fileselection, bool magnets_on ) { }
void  DrawTracks3D::AddToTracks( const char* fileselection ){ }

//________________________________________
bool DrawTracks3D::DrawTrack( int itr, bool removeOld )
{  
  // itr >= 0 not implemented
  if( itr != -1 ) return false;
  
  // Check if this is the first call, but do nothing
  if( trackId_ < 0 ) trackId_ = 0;
  
  // Check trackId_ is not too big/too small
  list< CsTrack* > tracks = CsEvent::Instance()->getTracks();
  if( trackId_ >= int(tracks.size()) ) {   
    
    // finish current event, try loading new event
    if( !CsRegistrySing::Instance()->callEoeMethods() ) exit(0);
    if( !CsEvent::Instance()->getNextEvent() ) {
      cout << "DrawTracks3D::DrawTracks - no more events.\n";
      return false;
    }
    eventId_ = int( CsEvent::Instance()->getEventNumberInRun() );
    WriteToLog( "evt %i", eventId_ );
    tracks = CsEvent::Instance()->getTracks();
    trackId_ = 0;
  }

  // check if detectors have to be (re)drawn
  if( detSelEntry_ ) {
    string detselection = string( detSelEntry_->GetText() );
    if( detselection != detselection_ ) DrawDetectors();
  } else if( !drawnDetIds_.size() ) DrawDetectors();
  
  if( removeOld ) {
    bool erased = false;
    // remove drawn tracks
    for( unsigned int i=0; i < tracks3D_.size(); i++ ) 
    if( tracks3D_[i] ) { erased = true; SafeDelete( tracks3D_[i] ); }
    tracks3D_.clear();
    
    // remove drawn wires (nodes and shapes only)
    for( unsigned int i=0; i < tWires3D_.size(); i++ ) 
    if( tWires3D_[i] ) { erased = true; tWires3D_[i]->DeleteTObjects(); }
    tWires3D_.clear(); 
    
    // redraw if something was erased
    if( erased ) { mainNode_->Draw(); cv_->Update(); }
    
  }
  
  // flush tracks until trackId_
  int itmp = 0;
  list< CsTrack* >::iterator It=tracks.begin();
  while( itmp < trackId_ && It!=tracks.end()  ){ It++; itmp++; }   
  if( It == tracks.end() ) return false; // something wrong. should not happen
  
  // increment trackId_ for next call
  trackId_++;   
  
  // first check the track matches enough
  int nMatchingDets = 0;
  list< CsCluster* > c = (*It)->getClusters();
  for( list< CsCluster* >::iterator Ic = c.begin(); Ic != c.end(); Ic++ ) {
    CsDetector *d = (*Ic)->getDetsList().front();
    if( d && drawnDetIds_.find( d->GetID() ) != drawnDetIds_.end() ) nMatchingDets++;
  }
  if( nMatchingDets < 2 ) {
    if( removeOld ) WriteToLog( "evt %i: track %i is empty", 
      eventId_, 
      trackId_ );
    return false;      
  }
      
  // look over helices, store them into a list
  list< CsHelix > lx;
  for( unsigned int i=0; i<(*It)->getHelices().size(); i++ ) {
    lx.push_back( (*It)->getHelices()[i] );
    lx.sort( sortLx() );
  }
  
  if( _IsDown( bridgedOnly_ ) && !lx.front().getCop() ) {
    if( removeOld ) WriteToLog( "evt %i: track %i not bridged", 
      eventId_, 
      trackId_ );
    return false;      
  }
      
  // create PolyLine3D object to store track points     
  char* buf = new char[64];
  sprintf( buf, "Track_%i", trackId_ );
  PolyLine3D *pline = new PolyLine3D( string( buf ) );
  SafeDelete( buf );
   
  // Store the position at which the first new wire will be booked
  int newWire = tWires3D_.size();  

  // get all hit detectors, store wires, draw them if required
  double zmin = 0;  // z for the most downstream matching detector in track
  double zmax = 0;  // z for the most upstream matching detector in track
  for( list< CsCluster* >::iterator Ic = c.begin(); Ic != c.end(); Ic++ ) {
    
    // check CsDetector
    CsDetector *d = (*Ic)->getDetsList().front();
    if( (!d) || drawnDetIds_.find( d->GetID() ) == drawnDetIds_.end() ) continue;
    DetectorInfo *di = df_->GetDetInfo( d->GetID() ); // check Matching DetectorInfo
    if( di->zcm_ < zmin || Ic == c.begin() ) zmin = di->zcm_;
    if( di->zcm_ > zmax || Ic == c.begin() ) zmax = di->zcm_;
    
    // store wire
    Obj3D* wire = di->GetWire3D( di->UtoWire( (*Ic)->getU() ) );
    if( wire ) tWires3D_.push_back( wire );
    
    // get closest helix to detector 
    double zD = di->zcm_;
    double dzMin = 0;
    CsHelix* lxMin = 0;
    list< CsHelix >::iterator Ilx;
    for( Ilx = lx.begin(); Ilx != lx.end(); Ilx ++ )
    if( (!lxMin) || fabs( (*Ilx).getZ()-zD ) < fabs(dzMin) ) {
      dzMin = (*Ilx).getZ()-zD;
      lxMin = &(*Ilx );
    } else break;
    
      
    // extrapolate lx to detector
    CsHelix *lxDet = new CsHelix();
    lxMin->Extrapolate( zD, *lxDet ); 
    
    // add point to Polyline3DObject
    pline->AddPoint( Point( lxDet->getX(), lxDet->getY(), lxDet->getZ() ) );
    
    SafeDelete(lxDet);
    
  }
  
  // add points in the midle of magnets 
  vector< MagnetInfo* > mags = df_->GetMagnetInfo();
  for( unsigned int i=0; i < mags.size(); i++ )
  if( zmin < mags[i]->zcm_ && zmax > mags[i]->zcm_ ) {
    double dzMin = 0;
    CsHelix* lxMin = 0;
    list< CsHelix >::iterator Ilx;
    for( Ilx = lx.begin(); Ilx != lx.end(); Ilx ++ )
    if( (!lxMin) || fabs( (*Ilx).getZ()-mags[i]->zcm_ ) < fabs(dzMin) ) {
      dzMin = (*Ilx).getZ()-mags[i]->zcm_;
      lxMin = &(*Ilx );
    } else break;
      
    // extrapolate lx to detector
    CsHelix *lxMag = new CsHelix();
    lxMin->Extrapolate( mags[i]->zcm_, *lxMag ); 
    
    // add point to Polyline3DObject
    pline->AddPoint( Point( lxMag->getX(), lxMag->getY(), lxMag->getZ() ) );
    SafeDelete(lxMag);
  }   
      
  // retrieve vertices extrapolate track to vertex, if needed
  list< CsVertex* > vertex = CsEvent::Instance()->getVertices();
  for( list< CsVertex* >::iterator Iv = vertex.begin(); Iv != vertex.end(); Iv++ )
  
  // check if vertex is enclosed between first and last detectors
  if( (*Iv)->getZ() >= detZMin_ && (*Iv)->getZ() <= detZMax_ ) {
    
    // check if current track is in vertex
    list< CsTrack* > vTracks = (*Iv)->getTracks();
    for( list< CsTrack* >::iterator Itv = vTracks.begin(); Itv != vTracks.end(); Itv++ )
    if( (*Itv) == (*It) ) {
      
      // get closest helix to vertex
      double dzMin = 0;
      CsHelix* lxMin = 0;
      list< CsHelix >::iterator Ilx;
      for( Ilx = lx.begin(); Ilx != lx.end(); Ilx ++ )
      if( (!lxMin) || fabs( (*Ilx).getZ()-(*Iv)->getZ() ) < fabs(dzMin) ) {
        dzMin = (*Ilx).getZ()-(*Iv)->getZ();
        lxMin = &(*Ilx );
      } else break;
      
      // extrapolate closest helix to vertex
      CsHelix *lxVertex = new CsHelix();
      lxMin->Extrapolate( (*Iv)->getZ(), *lxVertex ); 
      pline->AddPoint( Point( lxVertex->getX(), lxVertex->getY(), lxVertex->getZ() ) );
      SafeDelete( lxVertex );
    
    } // loop over tracks in vertex
  }   // look over vertices
    
  // draw Polyline3D
  pline->MakeNodes( rotNode_, trackColor, trackWidth );
  tracks3D_.push_back( (Obj3D*) pline );
  
  // draw new wires if required
  if( _IsDown(drawTWires_) )
  for( unsigned int i=newWire; i < tWires3D_.size(); i++ )
  if( tWires3D_[i] && !tWires3D_[i]->Drawn() ) 
  tWires3D_[i]->MakeNodes( rotNode_, tWireColor, wireWidth);
  
  
  // draw main node, if required
  if( removeOld ) {
    WriteToLog( "evt %i: track %i", eventId_, trackId_ );
    mainNode_->Draw();
    cv_->Update();
  }    
  
  return true;
  
}

//________________________________________
void DrawTracks3D::DrawEvent( void )
{  
  // initialise event id
  if( eventId_ < 0 )
  eventId_ = int( CsEvent::Instance()->getEventNumberInRun() );
 
  // draw detectors if needed
  if( !drawnDetIds_.size() ) DrawDetectors();
  
  // remove drawn tracks
  for( unsigned int i=0; i < tracks3D_.size(); i++ ) 
  if( tracks3D_[i] ) SafeDelete( tracks3D_[i] );
  tracks3D_.clear();
  
  // remove drawn track wires (nodes and shapes only)
  for( unsigned int i=0; i < tWires3D_.size(); i++ ) 
  if( tWires3D_[i] ) tWires3D_[i]->DeleteTObjects();
  tWires3D_.clear(); 
  
  // remove drawn wires hit in event (nodes and shapes only)
  for( unsigned int i=0; i < hWires3D_.size(); i++ ) 
  if( hWires3D_[i] ) hWires3D_[i]->DeleteTObjects();
  hWires3D_.clear(); 
 
  // get all clusters in event, draw corresponding wires, if required
  list< CsCluster* > c = CsEvent::Instance()->getClusters();
  for( list< CsCluster* >::iterator Ic = c.begin(); Ic != c.end(); Ic++ ) {
    
    // check CsDetector
    CsDetector *d = (*Ic)->getDetsList().front();
    if( (!d) || drawnDetIds_.find( d->GetID() ) == drawnDetIds_.end() ) continue;
    DetectorInfo *di = df_->GetDetInfo( d->GetID() ); // check Matching DetectorInfo
    
    // store wire
    Obj3D* wire = di->GetWire3D( di->UtoWire( (*Ic)->getU() ) );
    if( wire ) {
      hWires3D_.push_back( wire );
      if( _IsDown( drawHWires_ ) ) wire->MakeNodes( rotNode_, hWireColor, wireWidth );
    }
  }
  
  list< CsTrack* > tracks = CsEvent::Instance()->getTracks();
  
  trackId_ = 0; // reinit trackId_ to have the full event
  int nTracksDrawn = 0;
  for(list< CsTrack* >::iterator It = tracks.begin(); It != tracks.end(); It++ )
  if( DrawTrack( -1, false ) ) nTracksDrawn++;
  
  if( nTracksDrawn )
  WriteToLog( "evt %i: %i track%s", 
    eventId_, 
    nTracksDrawn,
    (nTracksDrawn > 1)? "s":"" );
  else WriteToLog( "evt %i: empty" , eventId_);
  
  mainNode_->Draw();
  cv_->Update();
  
  // End of event methods
  if( !(CsRegistrySing::Instance()->callEoeMethods()) ) exit(0);
  
  // try loading new event
  if( !CsEvent::Instance()->getNextEvent() ) {
    cout << "DrawTracks3D::DrawEvent - no more events.\n";
    return;
  }
  
  eventId_ = int( CsEvent::Instance()->getEventNumberInRun() );
  trackId_ = 0;
  
}   

//________________________________________
void  DrawTracks3D::_Init( void )
{
  if( drawTWires_ )  drawTWires_->SetState( kButtonDown );   // wires in track
  if( drawHWires_ )  drawHWires_->SetState( kButtonUp );     // wires hit in event 
  if( drawMagnets_ ) drawMagnets_->SetState( kButtonDown ); // magnets 
  if( bridgedOnly_ ) bridgedOnly_->SetState( kButtonUp );   // tracks with momentum
  
  // Draw all required detectors
  DrawDetectors();
  return;
}   

//_________________________________________ 
void DrawTracks3D::Exit( void ) 
{ 
  //=== End session ===
  CsRegistrySing::Instance()->callEndMethods();
  CsErrLog::Instance()->dump( elDebugging );
  exit(0);
}

//_________________________________________ 
unsigned int DrawTracks3D::_GetNMatchingDets( void )
{ return 0; }

